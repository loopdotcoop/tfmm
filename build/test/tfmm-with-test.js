// Generated by CoffeeScript 1.9.2

/*! Tfmm 0.0.22 //// MIT Licence //// http://tfmm.loop.coop/ */

(function() {
  var Asset, AssetManager, Blot, Flourish, Maestro, Main, MicIn, Tudor, Voice, VoiceSet, tudor, ª, ªA, ªB, ªE, ªF, ªI, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªclone, ªex, ªhas, ªkeymaps, ªpopulate, ªredefine, ªretrieve, ªtype, ªuid,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  ªI = 'Tfmm';

  ªV = '0.0.22';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  ªretrieve = function(instances, identifier) {
    var instance;
    instance = instances[identifier];
    if (!instance) {
      switch (typeof identifier) {
        case ªS:
          throw new Error("'" + identifier + "' does not exist");
          break;
        case ªN:
          throw new Error("`" + identifier + "` does not exist");
          break;
        case ªU:
          throw new Error("`identifier` is `undefined`");
          break;
        default:
          throw new Error("`identifier` is type '" + (ªtype(identifier)) + "'");
      }
    }
    return instance;
  };

  ªkeymaps = {
    qwerty: {
      k2l: {
        81: [0, 0, 0],
        87: [1, 0, 1],
        69: [2, 0, 2],
        82: [3, 0, 3],
        84: [4, 0, 4],
        89: [5, 0, 5],
        85: [6, 0, 6],
        73: [7, 0, 7],
        79: [8, 0, 8],
        80: [9, 0, 9],
        65: [0, 1, 10],
        83: [1, 1, 11],
        68: [2, 1, 12],
        70: [3, 1, 13],
        71: [4, 1, 14],
        72: [5, 1, 15],
        74: [6, 1, 16],
        75: [7, 1, 17],
        76: [8, 1, 18],
        90: [0, 2, 19],
        88: [1, 2, 20],
        67: [2, 2, 21],
        86: [3, 2, 22],
        66: [4, 2, 23],
        78: [5, 2, 24],
        77: [6, 2, 25]
      }
    }
  };

  ªpopulate = function(candidate, subject, rules, updating) {
    var errors, j, key, l, len, len1, rule, test, type, use, value;
    if (ªO !== ªtype(candidate)) {
      throw new Error("`candidate` is type '" + (ªtype(candidate)) + "' not 'object'");
    }
    errors = [];
    for (j = 0, len = rules.length; j < len; j++) {
      rule = rules[j];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (updating || void 0 !== use) {
          continue;
        } else {
          errors.push("Missing field '" + key + "' is mandatory");
        }
      } else if (type !== ªtype(value)) {
        errors.push("Field '" + key + "' is type '" + (ªtype(value)) + "' not '" + type + "'");
      } else if (!test.test(value)) {
        errors.push("Field '" + key + "' is '" + value + "' which fails " + ('' + test));
      }
    }
    if (errors.length) {
      throw new Error(errors.join('\n'));
    }
    for (l = 0, len1 = rules.length; l < len1; l++) {
      rule = rules[l];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (void 0 === subject[key]) {
          if (ªA === ªtype(use)) {
            subject[key] = use[0].apply(this, use.slice(1));
          } else {
            subject[key] = use;
          }
        }
      } else {
        subject[key] = value;
      }
    }
  };

  ªclone = function(subject, rules) {
    var j, key, len, out, rule;
    out = {};
    for (j = 0, len = rules.length; j < len; j++) {
      rule = rules[j];
      key = ªS === typeof rule ? rule : rule[0];
      out[key] = subject[key];
    }
    return out;
  };

  Asset = (function() {
    Asset.prototype.C = 'Asset';

    Asset.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Asset(config) {
      if (config == null) {
        config = {};
      }
      this.setManager = bind(this.setManager, this);
      this.completeHandler = bind(this.completeHandler, this);
      this.loadHandler = bind(this.loadHandler, this);
      this.abortHandler = bind(this.abortHandler, this);
      this.errorHandler = bind(this.errorHandler, this);
      this.progressHandler = bind(this.progressHandler, this);
      this.state = 'init';
      this.progress = 0;
      this.manager = null;
      this.url = config.url;
      this.request = null;
      this.buffer = null;
    }

    Asset.prototype.load = function() {
      if ('init' !== this.state) {
        return 0;
      }
      this.state = 'loading';
      this.request = new XMLHttpRequest;
      this.request.addEventListener('progress', this.progressHandler, false);
      this.request.addEventListener('error', this.errorHandler, false);
      this.request.addEventListener('abort', this.abortHandler, false);
      this.request.addEventListener('load', this.loadHandler, false);
      this.request.open('GET', this.url, true);
      this.request.responseType = 'arraybuffer';
      this.request.send();
      return 1;
    };

    Asset.prototype.progressHandler = function(event) {
      if (event.lengthComputable) {
        this.progress = event.loaded / event.total;
        return this.manager.progressHandler();
      }
    };

    Asset.prototype.errorHandler = function(event) {
      ª(event);
      return this.manager.completeHandler('oh no, error!');
    };

    Asset.prototype.abortHandler = function(event) {
      ª(event);
      return this.manager.completeHandler('oh no, abort!');
    };

    Asset.prototype.loadHandler = function() {
      if (200 !== this.request.status) {
        return this.manager.completeHandler("Load error, status " + this.request.status);
      } else {
        this.state = 'processing';
        this.progress = 1;
        return this.manager.audioCtx.decodeAudioData(this.request.response, this.completeHandler, this.errorHandler);
      }
    };

    Asset.prototype.completeHandler = function(buffer) {
      this.buffer = buffer;
      this.state = 'complete';
      return this.manager.completeHandler();
    };

    Asset.prototype.setManager = function(manager) {
      if (!(manager instanceof AssetManager)) {
        throw new Error("`manager` must be an instance of `AssetManager`");
      }
      return this.manager = manager;
    };

    return Asset;

  })();

  AssetManager = (function() {
    AssetManager.prototype.C = 'AssetManager';

    AssetManager.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function AssetManager(config) {
      if (config == null) {
        config = {};
      }
      this.audioCtx = config.audioCtx;
      this.progress = 0;
      this.assets = [];
      this.onProgress = config.onProgress || function() {};
      this.onComplete = config.onComplete || function() {};
    }

    AssetManager.prototype.add = function(asset) {
      if (!(asset instanceof Asset)) {
        throw new Error("`asset` must be an instance of `Asset`");
      }
      asset.setManager(this);
      this.assets.push(asset);
      return this;
    };

    AssetManager.prototype.load = function() {
      var asset;
      return ((function() {
        var j, len, ref, results;
        ref = this.assets;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          asset = ref[j];
          results.push(asset.load());
        }
        return results;
      }).call(this)).reduce(function(a, b) {
        return a + b;
      });
    };

    AssetManager.prototype.progressHandler = function() {
      var i, progress;
      progress = 0;
      i = this.assets.length;
      while (i--) {
        progress += this.assets[i].progress;
      }
      return this.onProgress(progress / this.assets.length);
    };

    AssetManager.prototype.completeHandler = function(error) {
      var i;
      if (error) {
        return this.onComplete(error);
      }
      i = this.assets.length;
      while (i--) {
        if ('complete' !== this.assets[i].state) {
          return;
        }
      }
      return this.onComplete();
    };

    return AssetManager;

  })();

  Blot = (function() {
    Blot.prototype.C = 'Blot';

    Blot.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Blot(config) {
      if (config == null) {
        config = {};
      }
      this.xx = null;
    }

    return Blot;

  })();

  Blot.square = function(time, velocity, ctx2d, size) {
    var scale, topleft;
    scale = size * velocity * (1 - time);
    topleft = (size - scale) / 4;
    return ctx2d.fillRect(topleft, topleft, scale, scale);
  };

  Blot.circle = function(time, velocity, ctx2d, size) {
    var center, radius;
    radius = Math.max(size * velocity * (1 - time), 0);
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.arc(center, center, radius / 2, 0, 2 * Math.PI);
    return ctx2d.fill();
  };

  Blot.squtrisqu = function(time, velocity, ctx2d, size) {
    var center, halfScale, scale;
    velocity *= 0.6;
    if (0.5 < time) {
      time = 1 - time;
    }
    scale = size * velocity * (1 - time);
    halfScale = scale / 2;
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.moveTo(center - (halfScale * (1 - time)), center - halfScale);
    ctx2d.lineTo(center + (halfScale * (1 - time)), center - halfScale);
    ctx2d.lineTo(center + (scale * time), center + scale);
    ctx2d.lineTo(center - (scale * time), center + scale);
    return ctx2d.fill();
  };

  Blot.triangle = function(time, velocity, ctx2d, size) {
    var center, halfScale, scale;
    scale = size * velocity * (1 - time);
    halfScale = scale / 2;
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.moveTo(center, center - halfScale);
    ctx2d.lineTo(center + halfScale, center + scale);
    ctx2d.lineTo(center - halfScale, center + scale);
    return ctx2d.fill();
  };

  Blot.dots = function(time, velocity, ctx2d, size) {
    var i;
    i = 5;
    while (--i) {
      ctx2d.setTransform(1 / i * velocity, 0, 0, .5 / i, ((size * i) / 4 - (size / 4)) / 2, size / 2 - (size / 4 * velocity));
      Blot.circle(time, velocity, ctx2d, size);
    }
    return ctx2d.setTransform(1, 0, 0, 1, 0, 0);
  };

  Blot.galaxy = function(time, velocity, ctx2d, size) {
    var i;
    time = 1 - time;
    i = 5;
    while (i--) {
      ctx2d.setTransform(.5 / time, 0, 0, .5 / time / i, size / i / 4, size / 4);
      Blot.circle(time, velocity, ctx2d, size);
    }
    return ctx2d.setTransform(1, 0, 0, 1, 0, 0);
  };

  Blot.oddtriangle = function(time, velocity, ctx2d, size) {
    var center, halfScale, scale;
    scale = size * velocity * (1 - time);
    halfScale = scale / 2;
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.moveTo(center, center - halfScale);
    ctx2d.lineTo(center + halfScale, scale);
    ctx2d.lineTo(center - halfScale, scale);
    return ctx2d.fill();
  };

  Blot.barupdown = function(time, velocity, ctx2d, size) {
    var scale, topleft, width;
    if (0.5 > time) {
      time = 1 - time;
    }
    scale = size * velocity * (1 - time);
    topleft = (size - scale) / 2;
    width = Math.max(scale, size / 3);
    ctx2d.fillRect(topleft / 2, topleft, width, scale);
    if (0.9 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.8, width, size / 100);
      ctx2d.fillRect(topleft / 2, topleft * 1.2, width, size / 100);
    }
    if (0.7 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.6, width, size / 100);
      return ctx2d.fillRect(topleft / 2, topleft * 1.4, width, size / 100);
    }
  };

  Blot.circleupdown = function(time, velocity, ctx2d, size) {
    var center, radius;
    if (0.5 > time) {
      time = 1 - time;
    }
    radius = Math.max(size * velocity * (1 - time), 0);
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.arc(center, center, radius * 0.8, 0, 2 * Math.PI * time * velocity);
    ctx2d.fill();
    if (0.9 > time) {
      ctx2d.arc(center, center * 0.4 * (time + 1), radius * 0.6, 0, Math.PI * time * velocity);
      ctx2d.arc(center, center * 0.8 * (time + 1), radius * 0.6, 0, Math.PI * time * velocity);
      ctx2d.fill();
    }
    if (0.7 > time) {
      ctx2d.arc(center * 0.2 * (time + 1), center, radius * 0.4, 0, Math.PI * time * velocity);
      ctx2d.arc(center * 1.0 * (time + 1), center, radius * 0.4, 0, Math.PI * time * velocity);
      return ctx2d.fill();
    }
  };

  Blot.linecrowd = function(time, velocity, ctx2d, size) {
    var scale, topleft, width;
    if (0.5 > time) {
      time = 1 - time;
    }
    scale = size * velocity * (1 - time);
    topleft = (size - scale) / 2;
    topleft = topleft * ((Math.random() + 7) / 8);
    width = Math.max(scale, size / 2);
    ctx2d.rotate(0.03);
    if (0.6 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.8, width, size / 100);
      ctx2d.fillRect(topleft / 2, topleft * 1.2, width, size / 100);
    }
    if (0.7 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.6, width, size / 100);
      ctx2d.fillRect(topleft / 2, topleft * 1.4, width, size / 100);
    }
    if (0.8 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.4, width, size / 100);
      ctx2d.fillRect(topleft / 2, topleft * 1.6, width, size / 100);
    }
    if (0.9 > time) {
      ctx2d.fillRect(topleft / 2, topleft * 0.2, width, size / 100);
      ctx2d.fillRect(topleft / 2, topleft * 1.8, width, size / 100);
    }
    return ctx2d.setTransform(1, 0, 0, 1, 0, 0);
  };

  Blot.radiation = function(time, velocity, ctx2d, size) {
    var center, rTime, radius;
    rTime = 1 - time;
    radius = size * velocity * time * 0.1;
    center = size / 2;
    ctx2d.beginPath();
    ctx2d.arc(center, center, radius * 0.5, 0, 2 * Math.PI);
    ctx2d.fill();
    if (0.1 < time) {
      ctx2d.fillRect(center * 0.95 * velocity, size * 0.4 * rTime, size * 0.05 * velocity, center * 0.8 * rTime);
    }
    if (0.2 < time) {
      ctx2d.rotate(0.1);
      ctx2d.fillRect(center * 0.96 * velocity, size * 0.4 * rTime, size * 0.04 * velocity, center * 0.8 * rTime);
      ctx2d.beginPath();
      ctx2d.arc(center, center, radius * 0.35, 0, 2 * Math.PI);
      ctx2d.fill();
    }
    if (0.5 < time) {
      ctx2d.rotate(0.2);
      ctx2d.fillRect(center * 0.97 * velocity, size * 0.4 * rTime, size * 0.03 * velocity, center * 0.8 * rTime);
      ctx2d.beginPath();
      ctx2d.arc(center, center, radius * 0.2, 0, 2 * Math.PI);
      ctx2d.fill();
    }
    if (0.7 < time) {
      ctx2d.rotate(0.4);
      ctx2d.fillRect(center * 0.98 * velocity, size * 0.4 * rTime, size * 0.02 * velocity, center * 0.8 * rTime);
      ctx2d.beginPath();
      ctx2d.arc(center, center, radius * 0.1, 0, 2 * Math.PI);
      ctx2d.fill();
    }
    return ctx2d.setTransform(1, 0, 0, 1, 0, 0);
  };

  Flourish = (function() {
    Flourish.prototype.C = 'Flourish';

    Flourish.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Flourish(config) {
      if (config == null) {
        config = {};
      }
      this.voice = config.voice;
      this.blotRenderer = config.blotRenderer;
      this.hasScheduled = false;
      this.start = config.start;
      this.duration = config.duration;
      this.velocity = config.velocity;
    }

    Flourish.prototype.render = function(frame, ctx2d, size) {
      var now, time;
      now = frame.frac2000;
      if (this.start + this.duration < now) {
        return;
      }
      if (this.start > now) {
        return this.lookahead(now, frame);
      }
      this.hasScheduled = false;
      time = 1 / (this.duration / (now - this.start));
      return this.blotRenderer(time, this.velocity, ctx2d, size);
    };

    Flourish.prototype.lookahead = function(now, frame) {
      if (this.hasScheduled || this.start > now + 0.1) {
        return;
      }
      this.hasScheduled = true;
      return this.voice.play(this.velocity, frame.stamp + (this.start - now) * 2000);
    };

    return Flourish;

  })();

  Maestro = (function() {
    Maestro.prototype.C = 'Maestro';

    Maestro.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Maestro(config) {
      if (config == null) {
        config = {};
      }
      this.step = bind(this.step, this);
      this.audioCtx = config.audioCtx;
      this.renderers = config.renderers || [];
      if (config.raf) {
        this.raf = config.raf.bind(this);
      } else {
        this.raf = window.requestAnimationFrame.bind(window);
      }
      this.prevFlip2000 = -1;
    }

    Maestro.prototype.start = function() {
      return this.raf(this.step);
    };

    Maestro.prototype.step = function(stamp) {
      var cue, currFlip2000, flip2000, flip8000, fn1, j, len, ref, renderer;
      currFlip2000 = stamp % 2000;
      if (currFlip2000 >= this.prevFlip2000) {
        flip2000 = false;
      } else {
        flip2000 = true;
        if (currFlip2000 === stamp % 8000) {
          flip8000 = true;
        } else {
          flip8000 = false;
        }
      }
      this.prevFlip2000 = currFlip2000;
      cue = {
        stamp: stamp,
        flip2000: flip2000,
        flip8000: flip8000,
        frac2000: (stamp % 2000) / 2000,
        frac8000: (stamp % 8000) / 8000
      };
      ref = this.renderers;
      fn1 = function(renderer) {
        return renderer.render(cue);
      };
      for (j = 0, len = ref.length; j < len; j++) {
        renderer = ref[j];
        fn1(renderer);
      }
      return this.raf(this.step);
    };

    return Maestro;

  })();

  Main = (function() {
    Main.prototype.C = ªI;

    Main.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Main(config) {
      if (config == null) {
        config = {};
      }
      this.updater = bind(this.updater, this);
      this.onLoadComplete = bind(this.onLoadComplete, this);
      this.onLoadProgress = bind(this.onLoadProgress, this);
      this.audioCtx = this.initCtxAudio();
      this.active = null;
      this.arts = config.arts;
      this.maestro = new Maestro({
        audioCtx: this.audioCtx
      });
      this.allVoices = [];
      this.$$voiceSets = config.$$voiceSets;
      this.voiceSets = this.initVoiceSets();
      this.maestro.renderers = this.voiceSets;
      this.$progressWrap = document.createElement('div');
      this.$progressWrap.setAttribute('id', 'progress-wrap');
      document.body.appendChild(this.$progressWrap);
      this.$progressBar = document.createElement('span');
      this.$progressBar.setAttribute('id', 'progress-bar');
      this.$progressWrap.appendChild(this.$progressBar);
      this.assetManager = this.initAssetManager();
      this.assetManager.load();
    }

    Main.prototype.initCtxAudio = function() {
      var ctxAudio;
      ctxAudio = window.AudioContext || window.webkitAudioContext;
      if (!ctxAudio) {
        alert('Your browser does not support Web Audio, please upgrade. ');
        throw new Error('`AudioContext || webkitAudioContext` is falsey');
      }
      return new ctxAudio;
    };

    Main.prototype.initVoiceSets = function() {
      var $voiceSet, current, first, j, len, previous, voiceSets;
      voiceSets = (function() {
        var j, len, ref, results;
        ref = this.$$voiceSets;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          $voiceSet = ref[j];
          results.push((function(_this) {
            return function($voiceSet) {
              var fn1, front, k, l, len1, ref1, ref2, v;
              front = {};
              ref1 = _this.arts[$voiceSet.id].front;
              fn1 = function(k, v) {
                return front[k] = v;
              };
              for (l = 0, len1 = ref1.length; l < len1; l++) {
                ref2 = ref1[l], k = ref2[0], v = ref2[1];
                fn1(k, v);
              }
              return _this.arts[$voiceSet.id].voiceSet = new VoiceSet({
                $voiceSet: $voiceSet,
                front: front,
                maestro: _this.maestro,
                allVoices: _this.allVoices
              });
            };
          })(this)($voiceSet));
        }
        return results;
      }).call(this);
      if (voiceSets.length) {
        previous = null;
        for (j = 0, len = voiceSets.length; j < len; j++) {
          current = voiceSets[j];
          if (previous) {
            current.previous = previous;
            previous.next = current;
          } else {
            first = current;
          }
          previous = current;
        }
        current.next = first;
        first.previous = current;
      }
      return voiceSets;
    };

    Main.prototype.initAssetManager = function() {
      var assetManager, j, l, len, len1, ref, ref1, voice, voiceSet;
      assetManager = new AssetManager({
        onProgress: this.onLoadProgress,
        onComplete: this.onLoadComplete,
        audioCtx: this.audioCtx
      });
      ref = this.voiceSets;
      for (j = 0, len = ref.length; j < len; j++) {
        voiceSet = ref[j];
        ref1 = voiceSet.voices;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          voice = ref1[l];
          assetManager.add(voice.sample);
        }
      }
      return assetManager;
    };

    Main.prototype.onLoadProgress = function(progress) {
      return this.$progressBar.style.width = (progress * 100) + "%";
    };

    Main.prototype.onLoadComplete = function(error) {
      if (error) {
        return ª(error);
      } else {
        document.body.setAttribute('class', 'complete');
        this.enableUserInput();
        return this.maestro.start();
      }
    };

    Main.prototype.enableUserInput = function() {
      var $voiceSet, e, j, len, micIn, ref, results;
      try {
        micIn = new MicIn({
          ctxAudio: this.audioCtx,
          maestro: this.maestro,
          callback: {
            threshold: 0.5,
            fn: (function(_this) {
              return function(velocity) {
                if (null === _this.active) {
                  return;
                }
                return _this.active.trigger(velocity);
              };
            })(this)
          }
        });
      } catch (_error) {
        e = _error;
        alert(e);
      }
      window.addEventListener('keydown', (function(_this) {
        return function(event) {
          var allVoicesIndex, ref, ref1, ref2;
          if (49 <= event.keyCode && 57 >= event.keyCode) {
            _this.simulateClick((ref = _this.voiceSets[event.keyCode - 48 - 1]) != null ? ref.$canvas : void 0);
          }
          if (97 <= event.keyCode && 105 >= event.keyCode) {
            _this.simulateClick((ref1 = _this.voiceSets[event.keyCode - 96 - 1]) != null ? ref1.$canvas : void 0);
          }
          allVoicesIndex = (ref2 = ªkeymaps.qwerty.k2l[event.keyCode]) != null ? ref2[2] : void 0;
          if (ªN === typeof allVoicesIndex) {
            _this.allVoices[allVoicesIndex].trigger(1);
          }
          if (null === _this.active) {
            return;
          }
          if (48 === event.keyCode || 96 === event.keyCode) {
            _this.active.trigger(1);
          }
          if (37 === event.keyCode) {
            _this.simulateClick(_this.active.previous.$canvas);
          }
          if (39 === event.keyCode) {
            return _this.simulateClick(_this.active.next.$canvas);
          }
        };
      })(this));
      window.addEventListener('click', function() {
        return window.location.hash = '/';
      });
      ref = this.$$voiceSets;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        $voiceSet = ref[j];
        results.push((function($voiceSet) {
          return $voiceSet.addEventListener('click', function(event) {
            if (!ªhas(this.className, 'active')) {
              window.location.hash = this.id.substr(5).replace(/_/g, '/');
            } else {
              if (ªhas(event.target.className, 'visualizer')) {
                arts[this.id].voiceSet.trigger(1);
              } else if (ªhas(event.target.className, 'icon')) {
                ª(event.target);
              }
            }
            return event.stopPropagation();
          });
        })($voiceSet));
      }
      return results;
    };

    Main.prototype.updater = function(current) {
      var j, len, ref, voiceSet;
      this.active = null;
      ref = this.voiceSets;
      for (j = 0, len = ref.length; j < len; j++) {
        voiceSet = ref[j];
        if (voiceSet.deactivate) {
          voiceSet.deactivate();
        }
      }
      if (current.voiceSet) {
        this.active = current.voiceSet;
        return this.active.activate();
      }
    };

    Main.prototype.simulateClick = function($element) {
      var canceled, evt;
      if ($element) {
        evt = document.createEvent('MouseEvents');
        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        canceled = !$element.dispatchEvent(evt);
        if (canceled) {

        } else {

        }
      }
    };

    return Main;

  })();

  MicIn = (function() {
    MicIn.prototype.C = 'MicIn';

    MicIn.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function MicIn(config) {
      if (config == null) {
        config = {};
      }
      this.render = bind(this.render, this);
      this.initStream = bind(this.initStream, this);
      this.callbacks = [];
      if (config.callback) {
        this.callbacks.push(config.callback);
      }
      this.ctxAudio = config.ctxAudio;
      if (!this.ctxAudio) {
        throw new Error('`config.ctxAudio` not provided!');
      }
      this.maestro = config.maestro;
      if (!this.maestro) {
        throw new Error('`config.maestro` not provided!');
      }
      this.initUserMedia();
    }

    MicIn.prototype.initUserMedia = function() {
      return;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (!navigator.getUserMedia) {
        throw new Error('getUserMedia not supported!');
      }
      return navigator.getUserMedia({
        audio: true,
        video: false
      }, this.initStream, function(error) {
        if (/^Permission(Dismissed|Denied)Error$/.test(error.name)) {
          return ª("`getUserMedia()` got a '" + error.name + "'");
        } else {
          throw new Error('`getUserMedia()` error: ' + error.name);
        }
      });
    };

    MicIn.prototype.initStream = function(stream) {
      this.streamSource = this.ctxAudio.createMediaStreamSource(stream, 2);
      this.analyser = this.ctxAudio.createAnalyser();
      this.analyser.fftSize = 2048;
      this.bufferLength = this.analyser.frequencyBinCount;
      this.dataArray = new Uint8Array(this.bufferLength);
      this.streamSource.connect(this.analyser);
      return this.maestro.renderers.push(this);
    };

    MicIn.prototype.render = function(cue) {
      var highestPeak, i;
      this.analyser.getByteTimeDomainData(this.dataArray);
      highestPeak = 0;
      i = this.bufferLength;
      while (i--) {
        highestPeak = Math.max(highestPeak, this.dataArray[i]);
      }
      highestPeak = highestPeak / 128.0 - 1;
      if (0.3 < highestPeak) {
        return this.callbacks[0].fn(highestPeak * highestPeak);
      }
    };

    return MicIn;

  })();

  Voice = (function() {
    Voice.prototype.C = 'Voice';

    Voice.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function Voice(config) {
      if (config == null) {
        config = {};
      }
      this.flourishes = [];
      this.now = {};
      this.maestro = config.maestro;
      this.hasFocus = false;
      this.size = 16;
      this.$canvas = document.createElement('canvas');
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      this.$canvas.setAttribute('class', 'icon');
      config.$voiceSet.appendChild(this.$canvas);
      this.icon = this.$canvas.getContext('2d');
      this.visualizer = config.visualizer;
      this.color = this.icon.fillStyle = config.color;
      this.sample = new Asset({
        url: "asset/audio/" + config.sample + ".mp3"
      });
      this.blotRenderer = config.blotRenderer;
      this.duration = +config.duration;
    }

    Voice.prototype.activate = function() {
      this.size = 64;
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      return this.icon.fillStyle = this.color;
    };

    Voice.prototype.deactivate = function() {
      this.size = 16;
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      return this.icon.fillStyle = this.color;
    };

    Voice.prototype.render = function(frame, visSize) {
      var flourish, j, len, ref, results, time;
      this.now = frame;
      this.icon.clearRect(0, 0, this.size, this.size);
      time = 0.5 > frame.frac2000 ? 1 - frame.frac2000 : frame.frac2000;
      time = (time - 0.5) / 4;
      time += !this.hasFocus ? 0.6 : 0.3;
      this.blotRenderer(time, 1, this.icon, this.size);
      this.visualizer.fillStyle = this.color;
      ref = this.flourishes;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        flourish = ref[j];
        results.push(flourish.render(frame, this.visualizer, visSize));
      }
      return results;
    };

    Voice.prototype.trigger = function(velocity) {
      ª(this.duration);
      this.flourishes.push(new Flourish({
        start: this.now.frac2000,
        duration: this.duration,
        velocity: velocity,
        voice: this,
        blotRenderer: this.blotRenderer
      }));
      return this.play(velocity, 0);
    };

    Voice.prototype.play = function(velocity, stamp) {
      var gainNode, source;
      source = this.maestro.audioCtx.createBufferSource();
      source.buffer = this.sample.buffer;
      gainNode = this.maestro.audioCtx.createGain();
      source.connect(gainNode);
      gainNode.connect(this.maestro.audioCtx.destination);
      gainNode.gain.value = velocity;
      return source.start(stamp / 1000);
    };

    Voice.prototype.quieten = function(multiplier, threshold) {
      var flourish, i, results;
      i = this.flourishes.length;
      results = [];
      while (i--) {
        flourish = this.flourishes[i];
        flourish.velocity *= multiplier;
        if (threshold >= flourish.velocity) {
          results.push(this.flourishes.splice(i, 1));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Voice;

  })();

  VoiceSet = (function() {
    VoiceSet.prototype.C = 'VoiceSet';

    VoiceSet.prototype.toString = function() {
      return "[object " + this.C + "]";
    };

    function VoiceSet(config) {
      var i, voice;
      if (config == null) {
        config = {};
      }
      this.maestro = config.maestro;
      this.ID = config.$voiceSet.id;
      this.allVoices = config.allVoices;
      this.focus = 0;
      this.size = 128;
      this.points = config.front.points.split(/\s+/);
      this.bkgnd = config.front.bkgnd;
      this.colors = config.front.colors.split(/\s+/);
      this.samples = config.front.samples.split(/\s+/);
      this.blots = config.front.blots.split(/\s+/);
      this.durations = config.front.durations.split(/\s+/);
      if (5 < this.colors.length) {
        throw new Error("'" + this.ID + "' frontmatter contains " + this.colors.length + " colors");
      }
      if (this.samples.length !== this.colors.length) {
        throw new Error("'" + this.ID + "' frontmatter contains unequal colors and samples");
      }
      if (this.blots.length !== this.colors.length) {
        throw new Error("'" + this.ID + "' frontmatter contains unequal colors and blots");
      }
      this.$canvas = document.createElement('canvas');
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      this.$canvas.setAttribute('class', 'visualizer');
      config.$voiceSet.appendChild(this.$canvas);
      this.visualizer = this.$canvas.getContext('2d');
      this.visualizer.globalCompositeOperation = 'screen';
      this.voices = [];
      i = this.colors.length;
      while (i--) {
        voice = new Voice({
          $voiceSet: config.$voiceSet,
          color: this.colors[i],
          sample: this.samples[i],
          blotRenderer: Blot[this.blots[i]],
          duration: this.durations[i],
          visualizer: this.visualizer,
          maestro: this.maestro
        });
        this.voices.push(voice);
        this.allVoices.push(voice);
      }
      this.voices[0].focus = true;
    }

    VoiceSet.prototype.activate = function() {
      var j, len, ref, results, voice;
      this.size = 512;
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      ref = this.voices;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        voice = ref[j];
        results.push(voice.activate());
      }
      return results;
    };

    VoiceSet.prototype.deactivate = function() {
      var j, len, ref, results, voice;
      this.size = 128;
      this.$canvas.setAttribute('width', this.size + 'px');
      this.$canvas.setAttribute('height', this.size + 'px');
      ref = this.voices;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        voice = ref[j];
        results.push(voice.deactivate());
      }
      return results;
    };

    VoiceSet.prototype.render = function(frame) {
      var j, l, len, len1, len2, m, ref, ref1, ref2, voice;
      if (frame.flip2000) {
        ref = this.voices;
        for (j = 0, len = ref.length; j < len; j++) {
          voice = ref[j];
          voice.hasFocus = false;
        }
        if (this.voices.length <= ++this.focus) {
          this.focus = 0;
        }
        this.voices[this.focus].hasFocus = true;
        ref1 = this.voices;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          voice = ref1[l];
          voice.quieten(0.8, 0.05);
        }
      }
      this.visualizer.clearRect(0, 0, this.size, this.size);
      this.visualizer.fillStyle = this.bkgnd;
      this.visualizer.fillRect(0, 0, this.size, this.size);
      this.visualizer.globalCompositeOperation = 'screen';
      ref2 = this.voices;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        voice = ref2[m];
        voice.render(frame, this.size);
      }
      this.visualizer.setTransform(-1, 0, 0, 1, this.size, 0);
      this.visualizer.drawImage(this.$canvas, 0, 0);
      return this.visualizer.setTransform(1, 0, 0, 1, 0, 0);
    };

    VoiceSet.prototype.trigger = function(velocity) {
      return this.voices[this.focus].trigger(velocity);
    };

    return VoiceSet;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Main;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Main;
  } else {
    this[ªI] = Main;
  }

  Tudor = (function() {
    Tudor.prototype.I = 'Tudor';

    Tudor.prototype.toString = function() {
      return "[object " + I + "]";
    };

    Tudor.prototype.articles = [];

    function Tudor(opt) {
      this.opt = opt != null ? opt : {};
      this["do"] = bind(this["do"], this);
      switch (this.opt.format) {
        case 'html':
          this.pageHead = function(summary) {
            return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
          };
          this.pageFoot = function(summary) {
            return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
          };
          this.articleHead = function(heading, fail) {
            return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
          };
          this.articleFoot = '</div></article>';
          this.sectionHead = function(heading, fail) {
            return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
          };
          this.sectionFoot = '</div></section>';
          this.jobFormat = function(heading, result) {
            return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
          };
          this.tick = '<b class="pass">\u2713</b> ';
          this.cross = '<b class="fail">\u2718</b> ';
          break;
        default:
          this.pageHead = function(summary) {
            return "" + summary;
          };
          this.pageFoot = function(summary) {
            return "\n" + summary;
          };
          this.articleHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
          };
          this.articleFoot = '';
          this.sectionHead = function(heading, fail) {
            return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
          };
          this.sectionFoot = '';
          this.jobFormat = function(heading, result) {
            return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
          };
          this.jobFoot = '';
          this.tick = '\u2713';
          this.cross = '\u2718';
      }
    }

    Tudor.prototype.add = function(lines) {
      var article, i, line, runner, section;
      article = {
        sections: []
      };
      runner = null;
      section = null;
      if (ªA !== ªtype(lines)) {
        throw new Error("`lines` isn’t an array");
      }
      if (0 === lines.length) {
        throw new Error("`lines` has no elements");
      }
      if (ªS !== ªtype(lines[0])) {
        throw new Error("`lines[0]` isn’t a string");
      }
      article.heading = lines.shift();
      i = 0;
      while (i < lines.length) {
        line = lines[i];
        switch (ªtype(line)) {
          case ªO:
            if (!line.runner) {
              throw new Error("Errant object");
            }
            runner = line.runner;
            break;
          case ªF:
            section.jobs.push(line);
            break;
          case ªS:
            if (this.isAssertion(lines[i + 1], lines[i + 2])) {
              if (!section) {
                throw new Error("Cannot add an assertion here");
              }
              section.jobs.push([runner, line, lines[++i], lines[++i]]);
            } else {
              section = {
                heading: line,
                jobs: []
              };
              article.sections.push(section);
            }
        }
        i++;
      }
      return this.articles.push(article);
    };

    Tudor.prototype["do"] = function() {
      var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, l, len, len1, len2, m, mock, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
      pge = [];
      mock = null;
      pgePass = pgeFail = 0;
      ref = this.articles;
      for (j = 0, len = ref.length; j < len; j++) {
        article = ref[j];
        art = [];
        artPass = artFail = 0;
        ref1 = article.sections;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          section = ref1[l];
          sec = [];
          secPass = secFail = 0;
          ref2 = section.jobs;
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            job = ref2[m];
            switch (ªtype(job)) {
              case ªF:
                try {
                  mock = job(mock);
                } catch (_error) {
                  e = _error;
                  error = e.message;
                }
                if (error) {
                  sec.push(this.formatMockModifierError(job, error));
                }
                break;
              case ªA:
                runner = job[0], heading = job[1], expect = job[2], actual = job[3];
                result = runner(expect, actual, mock);
                if (!result) {
                  sec.push(this.jobFormat("" + (this.sanitize(heading))));
                  pgePass++;
                  artPass++;
                  secPass++;
                } else {
                  sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                  pgeFail++;
                  artFail++;
                  secFail++;
                }
            }
          }
          sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
          sec.push(this.sectionFoot);
          art = art.concat(sec);
        }
        art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
        art.push(this.articleFoot);
        pge = pge.concat(art);
        summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      }
      pge.unshift(this.pageHead(summary));
      pge.push(this.pageFoot(summary));
      return pge.join('\n');
    };

    Tudor.prototype.formatError = function(result) {
      switch (result.length + "-" + this.opt.format) {
        case '2-html':
          return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
        case '2-plain':
          return result[0] + "\n" + (this.sanitize(result[1].message));
        case '3-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
        case '3-plain':
          return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
        case '4-html':
          return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
        case '4-plain':
          return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
        default:
          throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
      }
    };

    Tudor.prototype.formatMockModifierError = function(fn, error) {
      switch (this.opt.format) {
        case 'html':
          return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
        default:
          return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
      }
    };

    Tudor.prototype.reveal = function(value) {
      return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
        return '\u00b7' + (new Array(match.length)).join('\u00b7');
      }) : void 0;
    };

    Tudor.prototype.sanitize = function(value) {
      switch (this.opt.format) {
        case 'html':
          return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
        default:
          return value;
      }
    };

    Tudor.prototype["throw"] = {
      runner: function(expect, actual, mock) {
        var e, error;
        error = false;
        try {
          actual(mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (!error) {
          return [
            'No exception thrown, expected', {
              message: expect
            }
          ];
        } else if (expect !== error.message) {
          return [error.message, 'was thrown, but expected', expect];
        }
      }
    };

    Tudor.prototype.equal = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual(mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== result) {
          if (result + '' === expect + '') {
            return [result, 'was returned, but expected', expect, true];
          } else {
            return [result, 'was returned, but expected', expect];
          }
        }
      }
    };

    Tudor.prototype.is = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual(mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (expect !== ªtype(result)) {
          return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
        }
      }
    };

    Tudor.prototype.match = {
      runner: function(expect, actual, mock) {
        var e, error, result;
        error = false;
        try {
          result = actual(mock);
        } catch (_error) {
          e = _error;
          error = e;
        }
        if (error) {
          return ['Unexpected exception', error];
        } else if (ªF !== typeof expect.test) {
          return [
            '`test()` is not a function', {
              message: expect
            }
          ];
        } else if (!expect.test('' + result)) {
          return ['' + result, 'failed test', expect];
        }
      }
    };

    Tudor.prototype.isAssertion = function(line1, line2) {
      if (ªF !== ªtype(line2)) {
        return false;
      }
      if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
        return false;
      }
      return true;
    };

    return Tudor;

  })();

  tudor = new Tudor({
    format: ªO === typeof window ? 'html' : 'plain'
  });

  Main.runTest = tudor["do"];

  tudor.add([
    "01 Tfmm Constructor Usage", "The class and instance are expected types", tudor.is, "The class is a function", ªF, function() {
      return Main;
    }
  ]);

  tudor.add([
    "02 Asset and AssetManager Usage", "The classes and instances are expected types", tudor.is, "The Asset class is a function", ªF, function() {
      return Asset;
    }, "The AssetManager class is a function", ªF, function() {
      return AssetManager;
    }, "An Asset instance is an object", ªO, function() {
      return new Asset;
    }, "An AssetManager instance is an object", ªO, function() {
      return new AssetManager;
    }, tudor.equal, "The Asset class is an `instanceof` a `Function`", true, function() {
      return Asset instanceof Function;
    }, "The AssetManager class is an `instanceof` a `Function`", true, function() {
      return AssetManager instanceof Function;
    }, "An Asset instance is an `instanceof` an `Object`", true, function() {
      return new Asset instanceof Object;
    }, "An AssetManager instance is an `instanceof` an `Object`", true, function() {
      return new AssetManager instanceof Object;
    }, "An Asset instance is an `instanceof` the Asset class", true, function() {
      return new Asset instanceof Asset;
    }, "An AssetManager instance is an `instanceof` the AssetManager class", true, function() {
      return new AssetManager instanceof AssetManager;
    }, "Asset public members exist, and are accessible as expected", "Asset class has no enumerable properties", 0, function() {
      var prop;
      return ((function() {
        var results;
        results = [];
        for (prop in Asset) {
          results.push(prop);
        }
        return results;
      })()).length;
    }, function() {
      return new Asset;
    }, "Asset instance has expected enumerable properties", 'setManager,completeHandler,loadHandler,abortHandler,errorHandler,progressHandler,state,progress,manager,url,request,buffer,C,toString,load', function(mock) {
      var prop;
      return ((function() {
        var results;
        results = [];
        for (prop in mock) {
          results.push(prop);
        }
        return results;
      })()).join();
    }, "`C` is 'Asset'", 'Asset', function(mock) {
      return mock.C;
    }, "`toString()` is auto-assigned", '[object Asset]', function(mock) {
      return mock.toString();
    }, "`valueOf()` is the instance itself", true, function(mock) {
      return mock === mock.valueOf();
    }, "`state` is initially 'init'", 'init', function(mock) {
      return mock.state;
    }, "`progress` is initially `0`", 0, function(mock) {
      return mock.progress;
    }, "AssetManager public members exist, and are accessible as expected", "AssetManager class has no enumerable properties", 0, function() {
      var prop;
      return ((function() {
        var results;
        results = [];
        for (prop in Asset) {
          results.push(prop);
        }
        return results;
      })()).length;
    }, function() {
      return new AssetManager;
    }, "AssetManager instance has expected enumerable properties", 'audioCtx,progress,assets,onProgress,onComplete,C,toString,add,load,progressHandler,completeHandler', function(mock) {
      var prop;
      return ((function() {
        var results;
        results = [];
        for (prop in mock) {
          results.push(prop);
        }
        return results;
      })()).join();
    }, "`C` is 'AssetManager'", 'AssetManager', function(mock) {
      return mock.C;
    }, "`toString()` is auto-assigned", '[object AssetManager]', function(mock) {
      return mock.toString();
    }, "`valueOf()` is the instance itself", true, function(mock) {
      return mock === mock.valueOf();
    }, "`progress` is initially `0`", 0, function(mock) {
      return mock.progress;
    }, "`assets` is initially empty", 0, function(mock) {
      return mock.assets.length;
    }, "AssetManager can have Assets added to it", tudor["throw"], function() {
      return new AssetManager;
    }, "Added assets must be instances of Asset", '`asset` must be an instance of `Asset`', function(mock) {
      return mock.add(123);
    }, tudor.equal, "The first valid Asset is recorded when `add()`ed", 1, function(mock) {
      mock.add(new Asset);
      return mock.assets.length;
    }, "The second valid Asset is recorded when `add()`ed", 2, function(mock) {
      mock.add(new Asset);
      return mock.assets.length;
    }, "`AssetManager.load()` returns the number of newly loading Assets", "Before loading, both Assets’ states are 'init'", 'init,init', function(mock) {
      var asset;
      return ((function() {
        var j, len, ref, results;
        ref = mock.assets;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          asset = ref[j];
          results.push(asset.state);
        }
        return results;
      })()).join();
    }
  ]);

}).call(this);
