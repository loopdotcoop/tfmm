// Generated by CoffeeScript 1.9.2

/*! Tfmm 0.0.2 //// MIT Licence //// http://tfmm.loop.coop/ */

(function() {
  var Tfmm, ª, ªA, ªB, ªE, ªF, ªI, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªclone, ªex, ªhas, ªpopulate, ªredefine, ªretrieve, ªtype, ªuid;

  ªI = 'Tfmm';

  ªV = '0.0.2';

  ªA = 'array';

  ªB = 'boolean';

  ªE = 'error';

  ªF = 'function';

  ªN = 'number';

  ªO = 'object';

  ªR = 'regexp';

  ªS = 'string';

  ªU = 'undefined';

  ªX = 'null';

  ª = console.log.bind(console);

  ªex = function(x, a, b) {
    var pos;
    if (-1 === (pos = a.indexOf(x))) {
      return x;
    } else {
      return b.charAt(pos);
    }
  };

  ªhas = function(h, n, t, f) {
    if (t == null) {
      t = true;
    }
    if (f == null) {
      f = false;
    }
    if (-1 !== h.indexOf(n)) {
      return t;
    } else {
      return f;
    }
  };

  ªtype = function(x) {
    return {}.toString.call(x).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
  };

  ªuid = function(p) {
    return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
  };

  ªredefine = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };

  ªretrieve = function(instances, identifier) {
    var instance;
    instance = instances[identifier];
    if (!instance) {
      switch (typeof identifier) {
        case ªS:
          throw new Error("'" + identifier + "' does not exist");
          break;
        case ªN:
          throw new Error("`" + identifier + "` does not exist");
          break;
        case ªU:
          throw new Error("`identifier` is `undefined`");
          break;
        default:
          throw new Error("`identifier` is type '" + (ªtype(identifier)) + "'");
      }
    }
    return instance;
  };

  ªpopulate = function(candidate, subject, rules, updating) {
    var errors, i, j, key, len, len1, rule, test, type, use, value;
    if (ªO !== ªtype(candidate)) {
      throw new Error("`candidate` is type '" + (ªtype(candidate)) + "' not 'object'");
    }
    errors = [];
    for (i = 0, len = rules.length; i < len; i++) {
      rule = rules[i];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (updating || void 0 !== use) {
          continue;
        } else {
          errors.push("Missing field '" + key + "' is mandatory");
        }
      } else if (type !== ªtype(value)) {
        errors.push("Field '" + key + "' is type '" + (ªtype(value)) + "' not '" + type + "'");
      } else if (!test.test(value)) {
        errors.push("Field '" + key + "' is '" + value + "' which fails " + ('' + test));
      }
    }
    if (errors.length) {
      throw new Error(errors.join('\n'));
    }
    for (j = 0, len1 = rules.length; j < len1; j++) {
      rule = rules[j];
      key = rule[0], use = rule[1], type = rule[2], test = rule[3];
      value = candidate[key];
      if (void 0 === value) {
        if (void 0 === subject[key]) {
          if (ªA === ªtype(use)) {
            subject[key] = use[0].apply(this, use.slice(1));
          } else {
            subject[key] = use;
          }
        }
      } else {
        subject[key] = value;
      }
    }
  };

  ªclone = function(subject, rules) {
    var i, key, len, out, rule;
    out = {};
    for (i = 0, len = rules.length; i < len; i++) {
      rule = rules[i];
      key = ªS === typeof rule ? rule : rule[0];
      out[key] = subject[key];
    }
    return out;
  };

  Tfmm = (function() {
    Tfmm.prototype.I = ªI;

    Tfmm.prototype.ID = function() {
      return ªuid(this.I.toLowerCase());
    };

    Tfmm.prototype.toString = function() {
      return "[object " + this.I + "]";
    };

    function Tfmm(config) {
      var fn, key, value;
      if (config == null) {
        config = {};
      }
      fn = (function(_this) {
        return function(key, value) {
          if ('_' === key.substr(0, 1)) {
            ª(key);
            return ªredefine(_this, key, value, 'private');
          } else if (/^[_A-Z]+$/.test(key)) {
            if (ªF === typeof value) {
              value = _this[key]();
            }
            return ªredefine(_this, key, value, 'constant');
          }
        };
      })(this);
      for (key in this) {
        value = this[key];
        fn(key, value);
      }
      ªredefine(this, 'toString', this.toString, 'constant');
      ªredefine(this, 'valueOf', this.valueOf, 'constant');
      Object.freeze(this);
    }

    return Tfmm;

  })();

  if (ªF === typeof define && define.amd) {
    define(function() {
      return Tfmm;
    });
  } else if (ªO === typeof module && module && module.exports) {
    module.exports = Tfmm;
  } else {
    this[ªI] = Tfmm;
  }

}).call(this);
